```go
package execution

import (
	"context"

	"github.com/google/uuid"

	"github.com/build-on-sima/financial-bridge/pkg/domain/account"
	"github.com/build-on-sima/financial-bridge/pkg/events"
	"github.com/build-on-sima/financial-bridge/pkg/internal/errors"
)

// AccountCommandHandler processes commands related to the account domain.
// It acts as an orchestrator, loading the account aggregate, invoking its
// business logic, and persisting the results. This ensures a clear separation
// between the command-handling infrastructure and the core domain rules.
// This handler embodies the "fast for builders" principle by providing a clear,
// consistent pattern for modifying system state.
type AccountCommandHandler struct {
	repo account.Repository
}

// NewAccountCommandHandler creates a new handler for account commands.
// It requires a repository to load and save account aggregates.
func NewAccountCommandHandler(repo account.Repository) *AccountCommandHandler {
	if repo == nil {
		panic("account repository cannot be nil")
	}
	return &AccountCommandHandler{
		repo: repo,
	}
}

// CreateAccountCommand defines the data required to create a new account.
// The command is a simple data structure that represents an intent to change the system.
type CreateAccountCommand struct {
	AccountID uuid.UUID
	OwnerID   uuid.UUID
	Currency  string
	// Metadata can be used to store additional, non-critical information.
	Metadata map[string]string
}

// HandleCreateAccount executes the CreateAccountCommand.
// It follows a strict sequence:
// 1. Validate the command's input.
// 2. Check for idempotency to prevent duplicate account creation.
// 3. Delegate the core business logic to the account aggregate.
// 4. Persist the new aggregate and its creation event.
// This handler ensures that account creation is a deterministic and auditable process,
// making the system "boring to regulators".
func (h *AccountCommandHandler) HandleCreateAccount(ctx context.Context, cmd CreateAccountCommand) ([]events.Event, error) {
	const op = "AccountCommandHandler.HandleCreateAccount"

	if cmd.AccountID == uuid.Nil {
		return nil, errors.New(op, errors.CodeInvalidArgument, "AccountID cannot be nil")
	}
	if cmd.OwnerID == uuid.Nil {
		return nil, errors.New(op, errors.CodeInvalidArgument, "OwnerID cannot be nil")
	}
	// In a real system, currency would be validated against a list of supported currencies.
	if cmd.Currency == "" {
		return nil, errors.New(op, errors.CodeInvalidArgument, "Currency cannot be empty")
	}

	// Idempotency check: Ensure we don't create the same account twice.
	// The repository's Find method should return a specific error for not found,
	// which we handle. Any other error is a system failure.
	existing, err := h.repo.Find(ctx, cmd.AccountID)
	if err != nil && !errors.Is(err, errors.CodeNotFound) {
		return nil, errors.New(op, errors.CodeInternal, "failed to check for existing account", err)
	}
	if existing != nil {
		// If the account already exists, we treat it as a conflict.
		// The caller can decide if this is an error or a success (e.g., by re-fetching).
		return nil, errors.New(op, errors.CodeAlreadyExists, "account with ID %s already exists", cmd.AccountID)
	}

	// Delegate creation to the domain aggregate's factory function.
	// This keeps the business rule for what constitutes a valid new account
	// within the domain model itself.
	acc, err := account.NewAccount(cmd.AccountID, cmd.OwnerID, cmd.Currency, cmd.Metadata)
	if err != nil {
		// This error would typically stem from a domain invariant violation.
		return nil, errors.Wrap(op, "failed to create new account aggregate", err)
	}

	// Persist the newly created aggregate. The repository is responsible for
	// transactionally saving the state and the uncommitted events.
	if err := h.repo.Save(ctx, acc); err != nil {
		return nil, errors.New(op, errors.CodeInternal, "failed to save new account", err)
	}

	// Return the events generated by the aggregate for dispatching to other systems.
	return acc.UncommittedEvents(), nil
}

// CloseAccountCommand defines the data required to close an account.
type CloseAccountCommand struct {
	AccountID uuid.UUID
	Reason    string
}

// HandleCloseAccount executes the CloseAccountCommand.
// It loads the existing account, invokes the Close method, and saves the result.
// This ensures that an account can only be closed if it's in a valid state to do so
// (e.g., zero balance), as enforced by the aggregate's business logic.
func (h *AccountCommandHandler) HandleCloseAccount(ctx context.Context, cmd CloseAccountCommand) ([]events.Event, error) {
	const op = "AccountCommandHandler.HandleCloseAccount"

	if cmd.AccountID == uuid.Nil {
		return nil, errors.New(op, errors.CodeInvalidArgument, "AccountID cannot be nil")
	}

	// The core logic is encapsulated in a "load-act-save" pattern.
	acc, err := h.repo.Find(ctx, cmd.AccountID)
	if err != nil {
		// Propagate domain-specific errors (like NotFound) and wrap system errors.
		return nil, errors.Wrap(op, "failed to find account", err)
	}

	// Delegate the state transition logic to the aggregate.
	if err := acc.Close(cmd.Reason); err != nil {
		// This error indicates a business rule violation (e.g., closing an account with a balance).
		return nil, errors.Wrap(op, "failed to close account", err)
	}

	// Persist the changes.
	if err := h.repo.Save(ctx, acc); err != nil {
		return nil, errors.New(op, errors.CodeInternal, "failed to save closed account", err)
	}

	return acc.UncommittedEvents(), nil
}

// FreezeAccountCommand defines the data required to freeze an account.
type FreezeAccountCommand struct {
	AccountID uuid.UUID
	Reason    string
}

// HandleFreezeAccount executes the FreezeAccountCommand.
// It prevents debit transactions while allowing credits, a critical feature for
// risk management and compliance. The logic is delegated to the account aggregate.
// This makes the system feel "slow to attackers" by providing explicit, auditable controls.
func (h *AccountCommandHandler) HandleFreezeAccount(ctx context.Context, cmd FreezeAccountCommand) ([]events.Event, error) {
	const op = "AccountCommandHandler.HandleFreezeAccount"

	if cmd.AccountID == uuid.Nil {
		return nil, errors.New(op, errors.CodeInvalidArgument, "AccountID cannot be nil")
	}

	acc, err := h.repo.Find(ctx, cmd.AccountID)
	if err != nil {
		return nil, errors.Wrap(op, "failed to find account", err)
	}

	if err := acc.Freeze(cmd.Reason); err != nil {
		return nil, errors.Wrap(op, "failed to freeze account", err)
	}

	if err := h.repo.Save(ctx, acc); err != nil {
		return nil, errors.New(op, errors.CodeInternal, "failed to save frozen account", err)
	}

	return acc.UncommittedEvents(), nil
}

// UnfreezeAccountCommand defines the data required to unfreeze an account.
type UnfreezeAccountCommand struct {
	AccountID uuid.UUID
	Reason    string
}

// HandleUnfreezeAccount executes the UnfreezeAccountCommand.
// It reverses a freeze, re-enabling all transaction types. This action is
// just as important as freezing and is subject to the same rigorous
// load-act-save pattern to ensure auditability and deterministic state transitions.
func (h *AccountCommandHandler) HandleUnfreezeAccount(ctx context.Context, cmd UnfreezeAccountCommand) ([]events.Event, error) {
	const op = "AccountCommandHandler.HandleUnfreezeAccount"

	if cmd.AccountID == uuid.Nil {
		return nil, errors.New(op, errors.CodeInvalidArgument, "AccountID cannot be nil")
	}

	acc, err := h.repo.Find(ctx, cmd.AccountID)
	if err != nil {
		return nil, errors.Wrap(op, "failed to find account", err)
	}

	if err := acc.Unfreeze(cmd.Reason); err != nil {
		return nil, errors.Wrap(op, "failed to unfreeze account", err)
	}

	if err := h.repo.Save(ctx, acc); err != nil {
		return nil, errors.New(op, errors.CodeInternal, "failed to save unfrozen account", err)
	}

	return acc.UncommittedEvents(), nil
}

```