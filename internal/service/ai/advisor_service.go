package ai

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"time"

	"github.com/google/uuid"
)

// Common errors
var (
	ErrSessionNotFound = errors.New("chat session not found")
	ErrEmptyMessage    = errors.New("message content cannot be empty")
)

// Role represents the sender of a chat message.
type Role string

const (
	RoleSystem    Role = "system"
	RoleUser      Role = "user"
	RoleAssistant Role = "assistant"
)

// Message represents a single exchange in the conversation.
type Message struct {
	ID        uuid.UUID `json:"id"`
	SessionID uuid.UUID `json:"session_id"`
	Role      Role      `json:"role"`
	Content   string    `json:"content"`
	CreatedAt time.Time `json:"created_at"`
	Metadata  map[string]interface{}
}

// Session represents a chat conversation context.
type Session struct {
	ID        uuid.UUID `json:"id"`
	UserID    uuid.UUID `json:"user_id"`
	Title     string    `json:"title"`
	CreatedAt time.Time `json:"created_at"`
	UpdatedAt time.Time `json:"updated_at"`
}

// Repository defines the storage requirements for the advisor service.
// This interface allows the service to be decoupled from the specific database implementation.
type Repository interface {
	CreateSession(ctx context.Context, session *Session) error
	GetSession(ctx context.Context, id uuid.UUID) (*Session, error)
	GetUserSessions(ctx context.Context, userID uuid.UUID) ([]*Session, error)
	SaveMessage(ctx context.Context, msg *Message) error
	GetMessages(ctx context.Context, sessionID uuid.UUID) ([]*Message, error)
	UpdateSessionTitle(ctx context.Context, sessionID uuid.UUID, title string) error
}

// AIProvider defines the interface for interacting with LLMs (e.g., OpenAI, Anthropic).
type AIProvider interface {
	// GenerateResponse takes a history of messages and returns the AI's response.
	GenerateResponse(ctx context.Context, history []*Message, systemPrompt string) (string, error)
	// GenerateStream is optional for streaming responses, omitted here for simplicity but recommended for production.
}

// Service defines the public API for the AI Advisor.
type Service interface {
	StartNewSession(ctx context.Context, userID uuid.UUID, initialMessage string) (*Session, *Message, error)
	ContinueSession(ctx context.Context, sessionID uuid.UUID, content string) (*Message, error)
	GetHistory(ctx context.Context, sessionID uuid.UUID) ([]*Message, error)
	GetUserSessions(ctx context.Context, userID uuid.UUID) ([]*Session, error)
}

// AdvisorService implements the Service interface.
type AdvisorService struct {
	repo         Repository
	ai           AIProvider
	logger       *slog.Logger
	systemPrompt string
}

// NewAdvisorService creates a new instance of the AI Advisor service.
func NewAdvisorService(repo Repository, ai AIProvider, logger *slog.Logger) *AdvisorService {
	// Default system prompt. In a real app, this might be loaded from config or a database.
	defaultPrompt := `You are an expert AI Advisor for a high-performance Go application. 
Your goal is to provide accurate, concise, and production-ready advice. 
You prioritize clean code, security, and scalability.`

	return &AdvisorService{
		repo:         repo,
		ai:           ai,
		logger:       logger,
		systemPrompt: defaultPrompt,
	}
}

// SetSystemPrompt allows dynamic updating of the system persona.
func (s *AdvisorService) SetSystemPrompt(prompt string) {
	s.systemPrompt = prompt
}

// StartNewSession initializes a chat session and processes the first message.
func (s *AdvisorService) StartNewSession(ctx context.Context, userID uuid.UUID, initialMessage string) (*Session, *Message, error) {
	if initialMessage == "" {
		return nil, nil, ErrEmptyMessage
	}

	sessionID := uuid.New()
	now := time.Now().UTC()

	// Create Session
	session := &Session{
		ID:        sessionID,
		UserID:    userID,
		Title:     "New Conversation", // Could be generated by AI later based on context
		CreatedAt: now,
		UpdatedAt: now,
	}

	if err := s.repo.CreateSession(ctx, session); err != nil {
		s.logger.Error("failed to create session", "error", err, "user_id", userID)
		return nil, nil, fmt.Errorf("failed to create session: %w", err)
	}

	// Process the initial message
	response, err := s.processUserMessage(ctx, session, initialMessage)
	if err != nil {
		return nil, nil, err
	}

	// Attempt to generate a better title asynchronously (fire and forget)
	go s.generateTitle(context.Background(), session, initialMessage)

	return session, response, nil
}

// ContinueSession handles an ongoing conversation.
func (s *AdvisorService) ContinueSession(ctx context.Context, sessionID uuid.UUID, content string) (*Message, error) {
	if content == "" {
		return nil, ErrEmptyMessage
	}

	session, err := s.repo.GetSession(ctx, sessionID)
	if err != nil {
		s.logger.Warn("session not found", "session_id", sessionID)
		return nil, ErrSessionNotFound
	}

	return s.processUserMessage(ctx, session, content)
}

// GetHistory retrieves the message history for a session.
func (s *AdvisorService) GetHistory(ctx context.Context, sessionID uuid.UUID) ([]*Message, error) {
	return s.repo.GetMessages(ctx, sessionID)
}

// GetUserSessions retrieves all sessions for a specific user.
func (s *AdvisorService) GetUserSessions(ctx context.Context, userID uuid.UUID) ([]*Session, error) {
	return s.repo.GetUserSessions(ctx, userID)
}

// processUserMessage encapsulates the core logic of saving user input, calling AI, and saving AI output.
func (s *AdvisorService) processUserMessage(ctx context.Context, session *Session, userContent string) (*Message, error) {
	// 1. Save User Message
	userMsg := &Message{
		ID:        uuid.New(),
		SessionID: session.ID,
		Role:      RoleUser,
		Content:   userContent,
		CreatedAt: time.Now().UTC(),
	}

	if err := s.repo.SaveMessage(ctx, userMsg); err != nil {
		s.logger.Error("failed to save user message", "error", err, "session_id", session.ID)
		return nil, fmt.Errorf("failed to save message: %w", err)
	}

	// 2. Retrieve Context (History)
	// In a production app, we might limit this to the last N messages or use RAG to fetch relevant docs.
	history, err := s.repo.GetMessages(ctx, session.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to retrieve history: %w", err)
	}

	// 3. Generate AI Response
	aiResponseContent, err := s.ai.GenerateResponse(ctx, history, s.systemPrompt)
	if err != nil {
		s.logger.Error("failed to generate AI response", "error", err, "session_id", session.ID)
		return nil, fmt.Errorf("AI provider error: %w", err)
	}

	// 4. Save AI Message
	aiMsg := &Message{
		ID:        uuid.New(),
		SessionID: session.ID,
		Role:      RoleAssistant,
		Content:   aiResponseContent,
		CreatedAt: time.Now().UTC(),
	}

	if err := s.repo.SaveMessage(ctx, aiMsg); err != nil {
		s.logger.Error("failed to save AI response", "error", err, "session_id", session.ID)
		return nil, fmt.Errorf("failed to save AI response: %w", err)
	}

	return aiMsg, nil
}

// generateTitle uses the AI to generate a concise title for the session based on the first message.
func (s *AdvisorService) generateTitle(ctx context.Context, session *Session, initialMessage string) {
	// Create a short context with a timeout
	ctx, cancel := context.WithTimeout(ctx, 10*time.Second)
	defer cancel()

	prompt := fmt.Sprintf("Generate a short, concise title (max 5 words) for a conversation that starts with: %q", initialMessage)
	
	// We pass an empty history here as we just want a title based on the prompt
	title, err := s.ai.GenerateResponse(ctx, nil, prompt)
	if err != nil {
		s.logger.Warn("failed to generate session title", "error", err, "session_id", session.ID)
		return
	}

	// Clean up title (remove quotes if AI added them)
	// This is a naive cleanup; production code might use regex.
	if len(title) > 50 {
		title = title[:50] + "..."
	}

	if err := s.repo.UpdateSessionTitle(ctx, session.ID, title); err != nil {
		s.logger.Warn("failed to update session title", "error", err, "session_id", session.ID)
	}
}