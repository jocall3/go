package investment

import (
	"context"
	"errors"
	"fmt"
	"log/slog"
	"math"
	"time"

	"github.com/google/uuid"
)

// Errors defined for the investment service
var (
	ErrPortfolioNotFound = errors.New("portfolio not found")
	ErrInvalidAllocation = errors.New("target allocation must sum to 100%")
	ErrMarketDataUnavailable = errors.New("market data unavailable for rebalancing")
)

// -----------------------------------------------------------------------------
// Domain Models & DTOs
// -----------------------------------------------------------------------------

// Portfolio represents a user's investment container.
type Portfolio struct {
	ID          uuid.UUID
	UserID      uuid.UUID
	Name        string
	Description string
	Strategy    string // e.g., "Conservative", "Growth"
	Holdings    []Holding
	Targets     []TargetAllocation
	CreatedAt   time.Time
	UpdatedAt   time.Time
}

// Holding represents a current asset held in the portfolio.
type Holding struct {
	AssetSymbol string
	Quantity    float64
	AvgPrice    float64
}

// TargetAllocation represents the desired percentage for an asset.
type TargetAllocation struct {
	AssetSymbol string
	Percentage  float64 // 0.0 to 1.0 (e.g., 0.25 for 25%)
}

// Order represents a trade instruction generated by rebalancing.
type Order struct {
	ID          uuid.UUID
	PortfolioID uuid.UUID
	AssetSymbol string
	Action      string // "BUY" or "SELL"
	Quantity    float64
	EstimatedPx float64
	CreatedAt   time.Time
}

// CreatePortfolioRequest is the DTO for creating a portfolio.
type CreatePortfolioRequest struct {
	UserID      uuid.UUID
	Name        string
	Description string
	Strategy    string
	Targets     []TargetAllocation
}

// UpdatePortfolioRequest is the DTO for updating a portfolio.
type UpdatePortfolioRequest struct {
	ID          uuid.UUID
	Name        *string
	Description *string
	Strategy    *string
	Targets     []TargetAllocation
}

// -----------------------------------------------------------------------------
// Interfaces
// -----------------------------------------------------------------------------

// PortfolioRepository defines the data access layer for portfolios.
type PortfolioRepository interface {
	Create(ctx context.Context, p *Portfolio) error
	GetByID(ctx context.Context, id uuid.UUID) (*Portfolio, error)
	Update(ctx context.Context, p *Portfolio) error
	Delete(ctx context.Context, id uuid.UUID) error
	ListByUserID(ctx context.Context, userID uuid.UUID) ([]*Portfolio, error)
}

// MarketDataService defines the interface for retrieving current asset prices.
type MarketDataService interface {
	GetPrices(ctx context.Context, symbols []string) (map[string]float64, error)
}

// OrderService defines the interface for executing or queuing orders.
type OrderService interface {
	CreateOrders(ctx context.Context, orders []Order) error
}

// -----------------------------------------------------------------------------
// Service Implementation
// -----------------------------------------------------------------------------

// PortfolioService handles business logic for investment portfolios.
type PortfolioService struct {
	repo      PortfolioRepository
	market    MarketDataService
	orders    OrderService
	logger    *slog.Logger
}

// NewPortfolioService creates a new instance of PortfolioService.
func NewPortfolioService(
	repo PortfolioRepository,
	market MarketDataService,
	orders OrderService,
	logger *slog.Logger,
) *PortfolioService {
	return &PortfolioService{
		repo:   repo,
		market: market,
		orders: orders,
		logger: logger,
	}
}

// CreatePortfolio validates and persists a new portfolio.
func (s *PortfolioService) CreatePortfolio(ctx context.Context, req CreatePortfolioRequest) (*Portfolio, error) {
	s.logger.InfoContext(ctx, "creating new portfolio", "user_id", req.UserID, "name", req.Name)

	if err := validateAllocations(req.Targets); err != nil {
		return nil, err
	}

	portfolio := &Portfolio{
		ID:          uuid.New(),
		UserID:      req.UserID,
		Name:        req.Name,
		Description: req.Description,
		Strategy:    req.Strategy,
		Targets:     req.Targets,
		Holdings:    []Holding{}, // Empty initially
		CreatedAt:   time.Now(),
		UpdatedAt:   time.Now(),
	}

	if err := s.repo.Create(ctx, portfolio); err != nil {
		s.logger.ErrorContext(ctx, "failed to create portfolio", "error", err)
		return nil, fmt.Errorf("failed to create portfolio: %w", err)
	}

	return portfolio, nil
}

// GetPortfolio retrieves a portfolio by its ID.
func (s *PortfolioService) GetPortfolio(ctx context.Context, id uuid.UUID) (*Portfolio, error) {
	p, err := s.repo.GetByID(ctx, id)
	if err != nil {
		if errors.Is(err, ErrPortfolioNotFound) {
			return nil, ErrPortfolioNotFound
		}
		return nil, fmt.Errorf("failed to retrieve portfolio: %w", err)
	}
	return p, nil
}

// UpdatePortfolio modifies portfolio details and target allocations.
func (s *PortfolioService) UpdatePortfolio(ctx context.Context, req UpdatePortfolioRequest) (*Portfolio, error) {
	s.logger.InfoContext(ctx, "updating portfolio", "portfolio_id", req.ID)

	p, err := s.repo.GetByID(ctx, req.ID)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch portfolio for update: %w", err)
	}

	if req.Name != nil {
		p.Name = *req.Name
	}
	if req.Description != nil {
		p.Description = *req.Description
	}
	if req.Strategy != nil {
		p.Strategy = *req.Strategy
	}
	if len(req.Targets) > 0 {
		if err := validateAllocations(req.Targets); err != nil {
			return nil, err
		}
		p.Targets = req.Targets
	}

	p.UpdatedAt = time.Now()

	if err := s.repo.Update(ctx, p); err != nil {
		return nil, fmt.Errorf("failed to update portfolio: %w", err)
	}

	return p, nil
}

// RebalancePortfolio calculates the difference between current holdings and target allocations,
// generating orders to realign the portfolio.
func (s *PortfolioService) RebalancePortfolio(ctx context.Context, id uuid.UUID) ([]Order, error) {
	s.logger.InfoContext(ctx, "starting portfolio rebalancing", "portfolio_id", id)

	// 1. Fetch Portfolio
	p, err := s.repo.GetByID(ctx, id)
	if err != nil {
		return nil, fmt.Errorf("failed to fetch portfolio: %w", err)
	}

	if len(p.Targets) == 0 {
		return nil, errors.New("cannot rebalance portfolio with no target allocations")
	}

	// 2. Identify all unique symbols (holdings + targets)
	symbolSet := make(map[string]struct{})
	for _, h := range p.Holdings {
		symbolSet[h.AssetSymbol] = struct{}{}
	}
	for _, t := range p.Targets {
		symbolSet[t.AssetSymbol] = struct{}{}
	}

	symbols := make([]string, 0, len(symbolSet))
	for sym := range symbolSet {
		symbols = append(symbols, sym)
	}

	// 3. Get Current Market Prices
	prices, err := s.market.GetPrices(ctx, symbols)
	if err != nil {
		return nil, fmt.Errorf("%w: %v", ErrMarketDataUnavailable, err)
	}

	// 4. Calculate Total Portfolio Value
	var totalEquity float64
	currentValues := make(map[string]float64)

	for _, h := range p.Holdings {
		price, ok := prices[h.AssetSymbol]
		if !ok {
			s.logger.WarnContext(ctx, "missing price for asset, skipping in equity calc", "symbol", h.AssetSymbol)
			continue
		}
		val := h.Quantity * price
		currentValues[h.AssetSymbol] = val
		totalEquity += val
	}

	// If portfolio is empty (cash only or no holdings), we assume some cash deposit logic exists elsewhere,
	// but for rebalancing existing assets, if equity is 0, we can't rebalance without external cash info.
	// Assuming here we rebalance existing equity.
	if totalEquity <= 0 {
		s.logger.InfoContext(ctx, "total equity is zero, nothing to rebalance")
		return []Order{}, nil
	}

	// 5. Calculate Target Values and Generate Orders
	var orders []Order
	threshold := 0.01 // 1% deviation threshold to trigger trade (could be config)

	// Map targets for easy lookup
	targetMap := make(map[string]float64)
	for _, t := range p.Targets {
		targetMap[t.AssetSymbol] = t.Percentage
	}

	// Iterate over all involved symbols
	for _, sym := range symbols {
		price, ok := prices[sym]
		if !ok || price <= 0 {
			continue
		}

		currentVal := currentValues[sym]
		targetPct := targetMap[sym] // 0 if not in targets (sell all)
		targetVal := totalEquity * targetPct

		diff := targetVal - currentVal
		
		// Calculate drift percentage relative to total equity
		driftPct := math.Abs(diff) / totalEquity

		if driftPct < threshold {
			continue
		}

		qty := math.Abs(diff / price)
		// Round down to 6 decimal places to avoid floating point noise
		qty = math.Floor(qty*1000000) / 1000000

		if qty == 0 {
			continue
		}

		action := "BUY"
		if diff < 0 {
			action = "SELL"
		}

		order := Order{
			ID:          uuid.New(),
			PortfolioID: p.ID,
			AssetSymbol: sym,
			Action:      action,
			Quantity:    qty,
			EstimatedPx: price,
			CreatedAt:   time.Now(),
		}
		orders = append(orders, order)
	}

	// 6. Execute/Save Orders
	if len(orders) > 0 {
		if err := s.orders.CreateOrders(ctx, orders); err != nil {
			return nil, fmt.Errorf("failed to submit rebalancing orders: %w", err)
		}
		s.logger.InfoContext(ctx, "rebalancing orders generated", "count", len(orders))
	} else {
		s.logger.InfoContext(ctx, "portfolio is balanced, no orders generated")
	}

	return orders, nil
}

// -----------------------------------------------------------------------------
// Helper Functions
// -----------------------------------------------------------------------------

func validateAllocations(targets []TargetAllocation) error {
	var total float64
	for _, t := range targets {
		if t.Percentage < 0 {
			return errors.New("allocation percentage cannot be negative")
		}
		total += t.Percentage
	}

	// Allow small floating point error (epsilon)
	epsilon := 0.0001
	if math.Abs(total-1.0) > epsilon {
		return fmt.Errorf("%w: sum is %.4f", ErrInvalidAllocation, total)
	}
	return nil
}