package sustainability

import (
	"errors"
	"time"
)

// Common errors for the sustainability domain.
var (
	ErrInvalidAmount    = errors.New("amount must be greater than zero")
	ErrInvalidCategory  = errors.New("invalid emission category")
	ErrInvalidTimestamp = errors.New("timestamp cannot be in the future")
	ErrMissingSource    = errors.New("source of emission data is required")
)

// EmissionCategory represents the sector or type of activity causing emissions.
type EmissionCategory string

const (
	CategoryEnergy         EmissionCategory = "ENERGY"
	CategoryTransportation EmissionCategory = "TRANSPORTATION"
	CategoryManufacturing  EmissionCategory = "MANUFACTURING"
	CategoryAgriculture    EmissionCategory = "AGRICULTURE"
	CategoryWaste          EmissionCategory = "WASTE"
	CategoryDigital        EmissionCategory = "DIGITAL_INFRASTRUCTURE"
	CategoryOther          EmissionCategory = "OTHER"
)

// OffsetStatus represents the lifecycle state of a carbon offset.
type OffsetStatus string

const (
	StatusPending  OffsetStatus = "PENDING"
	StatusVerified OffsetStatus = "VERIFIED"
	StatusRetired  OffsetStatus = "RETIRED" // Permanently removed from circulation
	StatusFailed   OffsetStatus = "FAILED"
)

// Unit represents the unit of measurement for emissions (usually CO2e).
type Unit string

const (
	UnitKgCO2e     Unit = "KG_CO2E"
	UnitMetricTon  Unit = "METRIC_TON_CO2E"
	UnitGramCO2e   Unit = "GRAM_CO2E"
)

// CarbonFootprint represents a discrete record of carbon emissions generated by an entity.
type CarbonFootprint struct {
	ID          string           `json:"id"`
	EntityID    string           `json:"entity_id"` // User, Organization, or Device ID
	Category    EmissionCategory `json:"category"`
	Amount      float64          `json:"amount"` // The value of emissions
	Unit        Unit             `json:"unit"`
	Source      string           `json:"source"`      // e.g., "AWS Usage Report", "Smart Meter"
	Description string           `json:"description"` // Contextual details
	OccurredAt  time.Time        `json:"occurred_at"`
	RecordedAt  time.Time        `json:"recorded_at"`
	Metadata    map[string]any   `json:"metadata,omitempty"`
}

// NewCarbonFootprint creates a validated CarbonFootprint instance.
func NewCarbonFootprint(id, entityID string, category EmissionCategory, amount float64, unit Unit, source string, occurredAt time.Time) (*CarbonFootprint, error) {
	if amount <= 0 {
		return nil, ErrInvalidAmount
	}
	if source == "" {
		return nil, ErrMissingSource
	}
	if occurredAt.After(time.Now()) {
		return nil, ErrInvalidTimestamp
	}

	return &CarbonFootprint{
		ID:         id,
		EntityID:   entityID,
		Category:   category,
		Amount:     amount,
		Unit:       unit,
		Source:     source,
		OccurredAt: occurredAt,
		RecordedAt: time.Now(),
		Metadata:   make(map[string]any),
	}, nil
}

// CarbonOffset represents an action or purchase intended to compensate for emissions.
type CarbonOffset struct {
	ID             string         `json:"id"`
	EntityID       string         `json:"entity_id"`
	ProjectName    string         `json:"project_name"`
	ProjectID      string         `json:"project_id"` // External registry ID (e.g., Verra, Gold Standard)
	Amount         float64        `json:"amount"`     // Amount offset
	Unit           Unit           `json:"unit"`
	Cost           float64        `json:"cost"` // Monetary cost
	Currency       string         `json:"currency"`
	Status         OffsetStatus   `json:"status"`
	CertificateURL string         `json:"certificate_url,omitempty"`
	PurchasedAt    time.Time      `json:"purchased_at"`
	RetiredAt      *time.Time     `json:"retired_at,omitempty"`
	Metadata       map[string]any `json:"metadata,omitempty"`
}

// Retire marks the offset as retired (consumed), preventing double counting.
func (co *CarbonOffset) Retire() error {
	if co.Status == StatusRetired {
		return errors.New("offset is already retired")
	}
	now := time.Now()
	co.Status = StatusRetired
	co.RetiredAt = &now
	return nil
}

// ImpactAnalysis represents an aggregated report of sustainability metrics over a period.
type ImpactAnalysis struct {
	EntityID        string             `json:"entity_id"`
	PeriodStart     time.Time          `json:"period_start"`
	PeriodEnd       time.Time          `json:"period_end"`
	TotalEmissions  float64            `json:"total_emissions"`   // Normalized to Metric Tons
	TotalOffsets    float64            `json:"total_offsets"`     // Normalized to Metric Tons
	NetEmissions    float64            `json:"net_emissions"`     // Total - Offsets
	Breakdown       map[string]float64 `json:"breakdown"`         // Emissions by Category
	Recommendations []string           `json:"recommendations"`   // AI or rule-based suggestions
	GeneratedAt     time.Time          `json:"generated_at"`
}

// CalculateNet updates the NetEmissions field based on totals.
func (ia *ImpactAnalysis) CalculateNet() {
	ia.NetEmissions = ia.TotalEmissions - ia.TotalOffsets
	if ia.NetEmissions < 0 {
		ia.NetEmissions = 0 // Net negative is possible (carbon positive), but usually capped at 0 for reporting unless specific removal logic exists
	}
}

// IsCarbonNeutral returns true if offsets cover or exceed emissions.
func (ia *ImpactAnalysis) IsCarbonNeutral() bool {
	return ia.TotalOffsets >= ia.TotalEmissions
}

// ConvertToMetricTons is a helper to normalize units.
// This is a simplified converter. In a real app, this would handle complex unit conversions.
func ConvertToMetricTons(amount float64, unit Unit) float64 {
	switch unit {
	case UnitKgCO2e:
		return amount / 1000.0
	case UnitGramCO2e:
		return amount / 1_000_000.0
	case UnitMetricTon:
		return amount
	default:
		return amount
	}
}